# 深度測試(Depth testing)

原文     | [Depth testing](http://learnopengl.com/#!Advanced-OpenGL/Depth-testing)
      ---|---
作者     | JoeyDeVries
翻譯     | [Django](http://bullteacher.com/)
校對     | [Geequlim](http://geequlim.com)

在[座標系的教程](http://learnopengl-cn.readthedocs.org/zh/latest/01%20Getting%20started/08%20Coordinate%20Systems/)中我們呈現了一個3D容器,使用**深度緩衝**,以防止被其他面遮擋的面渲染到前面。在本教程中我們將細緻地討論被深度緩衝區(depth-buffer或z-buffer)所存儲的**深度值**以及它是如何確定一個片段是否被其他片段遮擋。

**深度緩衝**就像**顏色緩衝**(存儲所有的片段顏色:視覺輸出)那樣存儲每個片段的信息，(通常) 和顏色緩衝區有相同的寬度和高度。深度緩衝由窗口系統自動創建並將其深度值存儲為 16、 24 或 32 位浮點數。在大多數系統中深度緩衝區為24位。

當深度測試啟用的時候， OpenGL 測試深度緩衝區內的深度值。OpenGL 執行深度測試的時候，如果此測試通過，深度緩衝內的值將被設為新的深度值。如果深度測試失敗，則丟棄該片段。

深度測試在片段著色器運行之後(並且模板測試運行之後，我們將在[接下來](http://www.learnopengl.com/#!Advanced-OpenGL/Stencil-testing)的教程中討論)在屏幕空間中執行的。屏幕空間座標直接有關的視區，由OpenGL的`glViewport`函數給定，並且可以通過GLSL的片段著色器中內置的 `gl_FragCoord`變量訪問。`gl_FragCoord` 的 X 和 y 表示該片段的屏幕空間座標 ((0，0) 在左下角)。`gl_FragCoord` 還包含一個 z 座標，它包含了片段的實際深度值。此 z 座標值是與深度緩衝區的內容進行比較的值。

!!! Important

    現在大多數 GPU 都支持一種稱為提前深度測試(Early depth testing)的硬件功能。提前深度測試允許深度測試在片段著色器之前運行。明確一個片段永遠不會可見的 (它是其它物體的後面) 我們可以更早地放棄該片段。

    片段著色器通常是相當費時的所以我們應該儘量避免運行它們。對片段著色器提前深度測試一個限制是，你不應該寫入片段的深度值。如果片段著色器將寫入其深度值，提前深度測試是不可能的，OpenGL不能事先知道深度值。

深度測試默認是關閉的，要啟用深度測試的話，我們需要用`GL_DEPTH_TEST`選項來打開它：

```c++
glEnable(GL_DEPTH_TEST);
```

一旦啟用深度測試，如果片段通過深度測試，OpenGL自動在深度緩衝區存儲片段的 z 值，如果深度測試失敗，那麼相應地丟棄該片段。如果啟用深度測試，那麼在每個渲染之前還應使用`GL_DEPTH_BUFFER_BIT`清除深度緩衝區，否則深度緩衝區將保留上一次進行深度測試時所寫的深度值

```c++
glClear(GL_COLOR_BUFFER_BIT | GL_DEPTH_BUFFER_BIT);
```

在某些情況下我們需要進行深度測試並相應地丟棄片段，但我們不希望更新深度緩衝區，基本上，可以使用一個只讀的深度緩衝區；OpenGL允許我們通過將其深度掩碼設置為`GL_FALSE`禁用深度緩衝區寫入:

```c++
glDepthMask(GL_FALSE);
```

注意這隻在深度測試被啟用的時候有效。

## 深度測試函數

OpenGL 允許我們修改它深度測試使用的比較運算符(comparison operators)。這樣我們能夠控制OpenGL通過或丟棄碎片和如何更新深度緩衝區。我們可以通過調用`glDepthFunc`來設置比較運算符 (或叫做深度函數(depth function)):

```c++
glDepthFunc(GL_LESS);
```

該函數接受在下表中列出的幾個比較運算符:

運算符|描述
 ----------|------------------
 GL_ALWAYS |永遠通過測試
 GL_NEVER  |永遠不通過測試
 GL_LESS   |在片段深度值小於緩衝區的深度時通過測試
 GL_EQUAL  |在片段深度值等於緩衝區的深度時通過測試
 GL_LEQUAL |在片段深度值小於等於緩衝區的深度時通過測試
 GL_GREATER |在片段深度值大於緩衝區的深度時通過測試
 GL_NOTEQUAL|在片段深度值不等於緩衝區的深度時通過測試
 GL_GEQUAL |在片段深度值大於等於緩衝區的深度時通過測試

默認情況下使用`GL_LESS`，這將丟棄深度值高於或等於當前深度緩衝區的值的片段。

讓我們看看改變深度函數對輸出的影響。我們將使用新鮮的代碼安裝程序顯示一個沒有燈光的有紋理地板上的兩個有紋理的立方體。你可以在這裡找到源代碼和其著色器代碼。

代碼中我們將深度函數設為`GL_ALWAYS`:

```c++
glDepthFunc(GL_ALWAYS);
```

這和我們沒有啟用深度測試得到了相同的行為。深度測試只是簡單地通過，所以這樣最後繪製的片段就會呈現在之前繪製的片段前面，即使他們應該在前面。由於我們最後繪製地板平面，那麼平面的片段會覆蓋每個容器的片段:

![](http://learnopengl.com/img/advanced/depth_testing_func_always.png)

重新設置到`GL_LESS`給了我們曾經的場景：

![](http://learnopengl.com/img/advanced/depth_testing_func_less.png)

## 深度值精度

在深度緩衝區中包含深度值介於`0.0`和`1.0`之間，從觀察者看到其內容與場景中的所有對象的 z 值進行了比較。這些視圖空間中的 z 值可以在投影平頭截體的近平面和遠平面之間的任何值。我們因此需要一些方法來轉換這些視圖空間 z 值到 [0，1] 的範圍內，方法之一就是線性將它們轉換為 [0，1] 範圍內。下面的 (線性) 方程把 z 值轉換為 0.0 和 1.0 之間的值 :

![](../img/05_01_F_depth.png)

這裡far和near是我們用來提供到投影矩陣設置可見視圖截錐的遠近值 (見[座標系](http://learnopengl-cn.readthedocs.org/zh/latest/01%20Getting%20started/08%20Coordinate%20Systems/))。方程帶內錐截體的深度值 z，並將其轉換到 [0，1] 範圍。在下面的圖給出 z 值和其相應的深度值的關係:

![](http://learnopengl.com/img/advanced/depth_linear_graph.png)

!!! Important

    注意在物體接近近平面的時候，方程給出的深度值接近0.0，物體接近遠平面時，方程給出的深度接近1.0。

然而，在實踐中是幾乎從來不使用這樣的線性深度緩衝區。正確的投影特性的非線性深度方程是和1/z成正比的 。這樣基本上做的是在z很近是的高精度和 z 很遠的時候的低精度。用幾秒鐘想一想: 我們真的需要讓1000單位遠的物體和只有1單位遠的物體的深度值有相同的精度嗎?線性方程沒有考慮這一點。

由於非線性函數是和 1/z 成正比，例如1.0 和 2.0 之間的 z 值，將變為 1.0 到 0.5之間， 這樣在z非常小的時候給了我們很高的精度。50.0 和 100.0 之間的 Z 值將只佔 2%的浮點數的精度，這正是我們想要的。這類方程，也需要近和遠距離考慮，下面給出:

![](../img/05_01_F_depth_nonliner.png)

如果你不知道這個方程到底怎麼回事也不必擔心。要記住的重要一點是在深度緩衝區的值不是線性的屏幕空間 (它們在視圖空間投影矩陣應用之前是線性)。值為 0.5 在深度緩衝區並不意味著該對象的 z 值是投影平頭截體的中間;頂點的 z 值是實際上相當接近近平面!你可以看到 z 值和產生深度緩衝區的值在下列圖中的非線性關係:

![](http://learnopengl.com/img/advanced/depth_non_linear_graph.png)

正如你所看到，一個附近的物體的小的 z 值因此給了我們很高的深度精度。變換 (從觀察者的角度) 的 z 值的方程式被嵌入在投影矩陣，所以當我們變換頂點座標從視圖到裁剪，然後到非線性方程應用了的屏幕空間中。如果你好奇的投影矩陣究竟做了什麼我建議閱讀[這個文章](http://www.songho.ca/opengl/gl_projectionmatrix.html)。

接下來我們看看這個非線性的深度值。

### 深度緩衝區的可視化

我們知道在片段渲染器的內置`gl_FragCoord`向量的 z 值包含那個片段的深度值。如果我們要吧深度值作為顏色輸出，那麼我們可以在場景中顯示的所有片段的深度值。我們可以返回基於片段的深度值的顏色向量:

```c++
void main()
{
    color = vec4(vec3(gl_FragCoord.z), 1.0f);
}  
```

如果再次運行同一程序你可能會發現一切都是白的，它看起來像我們的深度值都是最大值 1.0。那麼為什麼沒有深度值接近 0.0而發暗?

你可能還記得從上一節中的屏幕空間的深度值是非線性如他們在z很小的時候有很高的精度，，較大的 z 值有較低的精度。該片段的深度值會迅速增加，所以幾乎所有頂點的深度值接近 1.0。如果我們小心的靠近物體，你最終可能會看到的色彩越來越暗，意味著它們的 z 值越來越小:

![](http://www.learnopengl.com/img/advanced/depth_testing_visible_depth.png)

這清楚地表明深度值的非線性特性。近的物體相對遠的物體對的深度值比對象較大的影響。只移動幾英寸就能讓暗色完全變亮。

但是我們可以讓深度值變換回線性。要實現這一目標我們需要讓點應用投影變換逆的逆變換，成為單獨的深度值的過程。這意味著我們必須首先重新變換範圍 [0，1] 中的深度值為單位化的設備座標(normalized device coordinates)範圍內 [-1，1] (裁剪空間(clip space))。然後，我們想要反轉非線性方程 (等式2) 就像在投影矩陣做的那樣並將此反轉方程應用於所得到的深度值。然後，結果是一個線性的深度值。聽起來能行對嗎?

首先，我們需要並不太難的 NDC 深度值轉換:

```c++
float z = depth * 2.0 - 1.0;
```

然後把我們所得到的 z 值應用逆轉換來檢索的線性深度值:

```c++
float linearDepth = (2.0 * near) / (far + near - z * (far - near));
```

注意此方程不是方程 2 的精確的逆方程。這個方程從投影矩陣中導出，可以從新使用等式2將他轉換為非線性深度值。這個方程也會考慮使用[0，1] 而不是 [near，far]範圍內的 z 值 。[math-heavy](http://www.songho.ca/opengl/gl_projectionmatrix.html)為感興趣的讀者闡述了大量詳細的投影矩陣的知識;它還表明了方程是從哪裡來的。

這不是從投影矩陣推導出的準確公式;這個方程是除以far的結果。深度值的範圍一直到far，這作為一個介於 0.0 和 1.0 之間的顏色值並不合適。除以far的值把深度值映射到介於 0.0 和 1.0，更適合用於演示目的。

這個能夠將屏幕空間的非線性深度值轉變為線性深度值的完整的片段著色器如下所示：

```c++
#version 330 core

out vec4 color;

float LinearizeDepth(float depth)
{
    float near = 0.1;
    float far = 100.0;
    float z = depth * 2.0 - 1.0; // Back to NDC
    return (2.0 * near) / (far + near - z * (far - near));
}

void main()
{
    float depth = LinearizeDepth(gl_FragCoord.z);
    color = vec4(vec3(depth), 1.0f);
}
```

如果現在運行該應用程序，我們得到在距離實際上線性的深度值。嘗試移動現場周圍看到深度值線性變化

![](http://www.learnopengl.com/img/advanced/depth_testing_visible_linear.png)。

顏色主要是黑色的因為深度值線性範圍從 0.1 的近平面到 100 的遠平面，那裡離我們很遠。其結果是，我們相對靠近近平面，從而得到較低 (較暗) 的深度值。

## 深度衝突

兩個平面或三角形如此緊密相互平行深度緩衝區不具有足夠的精度以至於無法得到哪一個靠前。結果是，這兩個形狀不斷似乎切換順序導致怪異出問題。這被稱為深度衝突，因為它看上去像形狀爭奪頂靠前的位置。

我們到目前為止一直在使用的場景中有幾個地方深度衝突很顯眼。容器被置於確切高度地板被安置這意味著容器的底平面與地板平面共面。兩個平面的深度值是相同的，因此深度測試也沒有辦法找出哪個是正確。

如果您移動攝像機到容器的裡面，那麼這個影響清晰可，容器的底部不斷切換容器的平面和地板的平面:

![](http://www.learnopengl.com/img/advanced/depth_testing_z_fighting.png)

深度衝突是深度緩衝區的普遍問題，當對象的距離越遠一般越強(因為深度緩衝區在z值非常大的時候沒有很高的精度)。深度衝突還無法完全避免，但有一般的幾個技巧，將有助於減輕或完全防止深度衝突在你的場景中的出現：

### 防止深度衝突

第一個也是最重要的技巧是讓物體之間不要離得太近，以至於他們的三角形重疊。通過在物體之間製造一點用戶無法察覺到的偏移，可以完全解決深度衝突。在容器和平面的條件下，我們可以把容器像+y方向上略微移動。這微小的改變可能完全不被注意但是可以有效地減少或者完全解決深度衝突。然而這需要人工的干預每個物體，並進行徹底地測試，以確保這個場景的物體之間沒有深度衝突。

另一個技巧是儘可能把近平面設置得遠一些。前面我們討論過越靠近近平面的位置精度越高。所以我們移動近平面遠離觀察者，我們可以在椎體內很有效的提高精度。然而把近平面移動的太遠會導致近處的物體被裁剪掉。所以不斷調整測試近平面的值，為你的場景找出最好的近平面的距離。

另外一個技巧是放棄一些性能來得到更高的深度值的精度。大多數的深度緩衝區都是24位。但現在顯卡支持32位深度值，這讓深度緩衝區的精度提高了一大節。所以犧牲一些性能你會得到更精確的深度測試，減少深度衝突。

我們已經討論過的 3 個技術是最常見和容易實現消除深度衝突的技術。還有一些其他技術需要更多的工作，仍然不會完全消除深度衝突。深度衝突是一個常見的問題，但如果你將列舉的技術適當結合你可能不會真的需要處理深度衝突。
